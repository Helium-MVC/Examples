<?php
namespace app\services;

use app\services\session\SessionService;
use Ramsey\Uuid\Uuid;
use Ramsey\Uuid\Exception\UnsatisfiedDependencyException;

/**
 * class LoggingService
 * 
 * The logging service is a class used to log the state of the actions that place on the system
 * along with the state of the system to a complete state of what is happening. The goal is to make analzying and
 * debugging easier but also increasing accountability.
 */
 
class LoggingService {
	
	private static $_meta = null;
	
	private static $_log_thread = null;
	
	//The model for saving the log too
	private static $_loggingModel;
	
	/**
	 * Initiatlizes the logger by setting the logging model.
	 */
	public static function init($loggingModel)  {
		self::$_loggingModel = $loggingModel;
	}
	
	/**
	 * Logs an action into the logging system.
	 * 
	 * @param string $action The name of the action
	 */
	public static function logAction($action, $entity_type= '', $entity_id = null, $entity_state = array(), $queue = false) {
			
		$data = array(
			'session_id' => SessionService::getID(),
			'user_id' => (SessionService::read('user_id')) ? SessionService::read('user_id') : null,
			'action' => $action,
			'entity_id'=> $entity_id,
			'entity_type' => $entity_type,
			'thread_id' => self::_getLogThread(),		
		);
		
		if(!$queue) {
			$loggingModel = self::$_loggingModel;
			$log = new $loggingModel();

			if($log -> create($data)) {
				$log -> setState($entity_state);
					
				$meta = self::_getMetaInfo();
				$log -> setMeta($meta);
			}
		} else {
				
			$data['entity_state'] = HStore::compileHStore($entity_state);
			$data['meta_data'] = HStore::compileHStore(self::_getMetaInfo());
				
			$queue = new QueueService();
			$queue ->add('log_add_queue', $data);
				
		}
		
		
	}
	
	/**
	 * Logs an action generated by a model to the logging system.
	 * 
	 * @param object $model An instance of an object that extends HModel
	 * @param string $action A name for action that can be used for sorting later
	 * @param id $entity_id An id of the entitiy that relates to the model
	 * @param boolean $queue Saves the data directly if false, sends to a queue for processing laser if true
	 */
	public static function logModelAction($model, $action, $entity_id = null, $queue = false) {
		
		if($model) {
			
			$data = array(
				'session_id' => SessionService::getID(),
				'user_id' => (SessionService::read('user_id')) ? SessionService::read('user_id') : null,
				'action' => $action,
				'entity_type' => 'model.'.$model -> getTableName(false),
				'thread_id' => self::_getLogThread(),
				'entity_id'=> $entity_id
			);
			
			if(!$queue) {
				$loggingModel = self::$_loggingModel;
				$log = new $loggingModel();

				if($log -> create($data)) {
					
					$state_data = $model -> getIterator() -> getData();
					
					if($action == $loggingModel::ACTION_CREATED_FAILED || $action == $loggingModel::ACTION_UPDATED_FAILED) {
						$error_message = $model -> getValidationErrors();
						
						if(is_array($error_message)) {
							$error_message = json_encode($error_message);
						}
						
						if($error_message) {
							$state_data['error_message'] = json_encode($error_message);	
						}
					}
					
					$log -> setState($state_data);
					
					$meta = self::_getMetaInfo();
					$log -> setMeta($meta);
				}
			} else {
				
				$data['entity_state'] = HStore::compileHStore($model -> getIterator() -> getData());
				$data['meta_data'] = HStore::compileHStore(self::_getMetaInfo());
				
				$queue = new QueueService();
				$queue ->add('log_add_queue', $data);
				
			}
		}
		
	}
	
	/**
	 * Logs the actions that occur regarding a service into the logging system.
	 * 
	 * @param instance $service An instance of the service that in which the action is being logged
	 * @param string $action The action to be logging
	 * @param array $state An array of data o be set as the date
	 */
	public static function logsServiceAction($service, string $action, array $state = array(), bool $queue = false) : void {
		
		if($service) {
			
			$data = array(
				'session_id' => SessionService::getID(),
				'user_id' => (SessionService::read('user_id')) ? SessionService::read('user_id') : null,
				'action' => $action,
				'entity_type' => 'service.'. strtolower(get_class($service)),
				'thread_id' => self::_getLogThread(),
				'entity_id'=> null
			);
			
			//Set the function that was called
			if(!isset($state['function'])) {
				$trace = debug_backtrace();
				if(isset($trace[1]) && $trace[1]) {
    				$state['function'] = $trace[1]["function"];
				}
			}
			
			if(!$queue) {
				$loggingModel = self::$_loggingModel;
				
				$log = new $loggingModel();

				if($log -> create($data)) {
					$log -> setState($state);
					
					$meta = self::_getMetaInfo();
					$log -> setMeta($meta);
				}
			} else {
				
				$data['entity_state'] = HStore::compileHStore($stata);
				$data['meta_data'] = HStore::compileHStore(self::_getMetaInfo());
				
				$queue = new QueueService();
				$queue ->add('log_add_queue', $data);
				
			}
		}
		
	}
	
	/**
	 * Log all the emails are that send from the system.
	 * 
	 * @param object $email An instance of the PHPMailer object
	 * @param boolean $successful_send If the email was successfully send
	 * @param array $options Additional options that can be saved with the log.
	 * 			user_id - The id of theuser
				request_id - The id of a request
				response_id - the id of a response
				credit_id' - The id of a credit,
	 * 			mail_type - The kind of message being send
	 */
	public static function logEmail($email, $successful_send, $options = array()) {
		/*
		$log = new EmailLogger();
		
		$data = array(
			'sent_status' => $successful_send,
			'subject' => $email -> Subject,
			'html_message' => $email -> Body,
			'text_message' => $email -> AltBody,
			'mail_id' => $email -> getLastMessageID()
		);
		
		$data += $options;
		
		if($log -> create($data)){
			
			$log -> setTo($email -> getToAddresses());
			
			$log -> setCC($email -> getCcAddresses());
			
			$log -> setBCC($email -> getBccAddresses());
			
		}//ebd if create
		*/
	}
	
	/**
	 * Log actions that are from controllers on the platform. Namely used for recording
	 * 404 and illegial access.
	 * 
	 * @param string $controller The name of the controller
	 * @param string $action The action being called within the controller
	 * @param string $message A message describing the error.
	 * @param array $data Data in array format to be stored in the state
	 * 
	 * @return void
	 */
	public static function logController($controller, $action, $message = '', $state = array()) {
			
		$data = array(
			'session_id' => SessionService::getID(),
			'user_id' => (SessionService::read('user_id')) ? SessionService::read('user_id') : null,
			'action' => $action,
			'entity_type' => 'controller.'.$controller,
			'thread_id' => self::_getLogThread(),
			'entity_id'=> null,
			'entity_state' => $message
		);
		
		$loggingModel = self::$_loggingModel;
		
		$log = new $loggingModel();

		if($log -> create($data)) {
			$log -> setState($state);
					
			$meta = self::_getMetaInfo();
			$log -> setMeta($meta);
		}
	}
			
	/**
	 * Retrives the information about the system and its current state to be stored
	 * in the logs.
	 * 
	 * @return array
	 */
	private static function _getMetaInfo() {
		
		if(self::$_meta) {
			
			//Gets all the server data
			//Should be called every time because state changes
			$server = new ServerService();
			
			$tmp_data = self::$_meta;
			$tmp_data += $server -> getAllData();
			
			self::$_meta = $tmp_data;
			
			return self::$_meta;
		}
		
		@$data = get_browser(null, true);

		foreach($_SERVER as $key => $value) {
			$data[$key] = $value;
		}
				
		//Gets all the server data
		//Should be called every time because state changes
		$server = new ServerService();
		$data += $server -> getAllData();
		
		self::$_meta = $data;
		
		return self::$_meta;
		
	}
	
	/**
	 * Gets the thread that will be used to sort the stored data. Threads are generated per process, and only
	 * one thread id is used per process.
	 * 
	 * @return uuid $thread_id
	 */
	private static function _getLogThread() {
		if(!self::$_log_thread) {
			try {
    			// Generate a version 5 (name-based and hashed with SHA1) UUID object
    			$uuid5 = Uuid::uuid4();
				self::$_log_thread = $uuid5->toString();

			} catch (UnsatisfiedDependencyException $e) {
				
				self::$_log_thread = uniqid('log_thread',true);
				
			}//end catch
			
		}
		
		return self::$_log_thread;
	}
	
	
}//end class
